<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/D_32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/D_16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="简介总结一些非常经典的套路">
<meta property="og:type" content="article">
<meta property="og:title" content="经典套路和技巧">
<meta property="og:url" content="http://example.com/2020/11/11/%E7%BB%8F%E5%85%B8%E5%A5%97%E8%B7%AF/index.html">
<meta property="og:site_name" content="DDOSvoid&#39;s Blog">
<meta property="og:description" content="简介总结一些非常经典的套路">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-11T12:01:46.000Z">
<meta property="article:modified_time" content="2022-07-30T15:26:47.270Z">
<meta property="article:author" content="DDOSvoid">
<meta property="article:tag" content="Tech">
<meta property="article:tag" content="套路">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2020/11/11/%E7%BB%8F%E5%85%B8%E5%A5%97%E8%B7%AF/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>经典套路和技巧 | DDOSvoid's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">DDOSvoid's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.</span> <span class="nav-text">一些注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">3.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">字典序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">5.</span> <span class="nav-text">前缀和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%AE%E5%88%86"><span class="nav-number">6.</span> <span class="nav-text">差分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">7.</span> <span class="nav-text">双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%88%A0%E9%99%A4%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">8.</span> <span class="nav-text">无删除双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0"><span class="nav-number">9.</span> <span class="nav-text">调和级数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E6%9D%82%E7%9A%84%E4%B8%9C%E8%A5%BF"><span class="nav-number">10.</span> <span class="nav-text">一些比较杂的东西</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="DDOSvoid"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">DDOSvoid</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">732</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">134</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/DDOSvoid" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DDOSvoid" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.luogu.com.cn/user/34531" title="Luogu → https:&#x2F;&#x2F;www.luogu.com.cn&#x2F;user&#x2F;34531" rel="noopener" target="_blank">Luogu</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://codeforces.com/profile/DDOSvoid" title="Codeforces → http:&#x2F;&#x2F;codeforces.com&#x2F;profile&#x2F;DDOSvoid" rel="noopener" target="_blank">Codeforces</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://acm.hdu.edu.cn/userstatus.php?user=DDOSvoid" title="Hdu → http:&#x2F;&#x2F;acm.hdu.edu.cn&#x2F;userstatus.php?user&#x3D;DDOSvoid" rel="noopener" target="_blank">Hdu</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fas fa-link fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/manziqi/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;manziqi&#x2F;" rel="noopener" target="_blank">Title1</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://jczhang.top/" title="https:&#x2F;&#x2F;jczhang.top&#x2F;" rel="noopener" target="_blank">JC Blog</a>
        </li>
    </ul>
  </div>

      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/11/%E7%BB%8F%E5%85%B8%E5%A5%97%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="DDOSvoid">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DDOSvoid's Blog">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          经典套路和技巧
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-11 20:01:46" itemprop="dateCreated datePublished" datetime="2020-11-11T20:01:46+08:00">2020-11-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-07-30 23:26:47" itemprop="dateModified" datetime="2022-07-30T23:26:47+08:00">2022-07-30</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-ACM/" itemprop="url" rel="index"><span itemprop="name">OI & ACM</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>总结一些非常经典的套路</p>
<a id="more"></a>
<h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><ol>
<li><p>用 $priority\underline{}queue$ 实现的可删除堆比 $multiset$ 要快接近一倍</p>
</li>
<li><p>$O(1)$ 计算二进制位的几个内置函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __builtin_ffs (<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span><br><span class="line">返回x的最后一位<span class="number">1</span>的是从后向前第几位</span><br><span class="line"><span class="keyword">int</span> __builtin_clz (<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span><br><span class="line">返回前导 <span class="number">0</span> 的个数</span><br><span class="line"><span class="keyword">int</span> __builtin_ctz (<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span><br><span class="line">返回后面的 <span class="number">0</span> 的个数，和 __builtin_clz 相对。</span><br><span class="line"><span class="keyword">int</span> __builtin_popcount (<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span><br><span class="line">返回二进制表示中 <span class="number">1</span> 的个数。</span><br><span class="line"><span class="keyword">int</span> __builtin_parity (<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span><br><span class="line">返回 x 的奇偶校验位，也就是 x 的 <span class="number">1</span> 的个数模 <span class="number">2</span> 的结果</span><br><span class="line"></span><br><span class="line">注意上面的函数都有对应 <span class="keyword">long</span> <span class="keyword">long</span> 版本</span><br><span class="line">例如:</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> __builtin_popcountll</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>一定要每一位单独考虑</p>
<ol>
<li><p>简要题意：给定一个有 $n$ 个点的完全图，无向边 $<u,v>$ 的权值为 $(u~xor~v)\times C$，$C$ 是给定的常数，现再给定 $m$ 条单向边 $(u,v,w)$ 和起点 $s$ 以及终点 $t$，求 $s$ 到 $t$​ 的最短路</p>
<p>$n\le 10^5,m\le 5\times 10^5$</p>
<p>简要题解：<strong>我们对于特殊的边按位考虑，也就是把边拆开，对于点 $u$，向 $u~xor~2^i$ 连边，边权为 $C\cdot2^i$</strong>​</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/11/Luogu-P4366-Code-4-%E6%9C%80%E7%9F%AD%E8%B7%AF/">Luogu P4366 [Code+#4]最短路</a> </p>
</li>
<li><p>简要题意：给定两个长度为 $n$ 的序列 $a_i$ 和 $b_i$，求 $\forall i\in[1,n],j\in[1,n],a_i+b_j$​ 的异或和</p>
<p>$n\le 2\times 10^5$​</p>
<p>简要题解：我们先将 $x$ 和 $y$ 对 $2^{k+1}-1$ 取模</p>
<p><strong>那么 $x+y$​ 的第 $k$​ 位是 $1$​ 的条件为 $2^k\le a_i+b_j&lt;2^{k+1},2^{k}+2^{k+1}\le a_i+b_j$​​ </strong></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/15/Luogu-T51127-SDSCD6T2-B/">Luogu T51127 SDSCD6T2</a> </p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的序列 $a_i$，将其划分成 $m$ 段连续区间，每段区间的费用为这段区间的异或和，求所有段的费用的或的最小值</p>
<p>$n\le 5\times 10^5$</p>
<p>简要题解：<strong>我们考虑分成 $m$​ 段相当于除了 $n$ 以外，再选 $m-1$​​​​ 个右端点</strong></p>
<p>然后我们考虑按位贪心，注意到如果某一位出现了奇数次那么它一定要算到答案里</p>
<p>否则我们维护合法的右端点，注意到对于第 $k$ 位，所有前缀异或和为 $0$​ 的点都可以作为一个右端点，而这个时候注意到点 $n$ 的前缀异或和一定是 $0$，所以我们只需要判断右端点的数量是否大于等于 $m$ 即可，然后每次做完将前缀异或和为 $1$ 的点标记为不能选为右端点</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/15/bzoj-4245-ONTAK2015-OR-XOR/">bzoj 4245 [ONTAK2015]OR-XOR</a> </p>
</li>
<li><p>简要题意：给定 $n$ 个数，求有多少对数，满足异或有奇数个 $1$</p>
<p>$n\le 10^7$</p>
<p>简要题解：<strong>异或不会改变两个数二进制下 $1$ 的个数的奇偶性</strong></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/15/Luogu-P4932-%E6%B5%8F%E8%A7%88%E5%99%A8/">Luogu P4932 浏览器</a> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/16/Luogu-P2114-NOI2014-起床困难综合症/">Luogu P2114 [NOI2014]起床困难综合症</a> 从高位到低位贪心</p>
</li>
<li><p>简要题意：给定一个边权均为 $1$ 的有向图，如果 $a_i~and~a_j=a_j$，则有一条 $i$ 连向 $j$ 的边，额外再给 $m$ 条有向边，求 $1$ 到其它所有点的最短路</p>
<p>$n\le 2\times 10^5,m\le 3\times 10^5,1\le a_i &lt; 2^{20}$</p>
<p>简要题解：一个显然的思路是建 $2^{20}$​ 个点，然后每个点向自己的子集连边，复杂度 $O(3^{20})$​ 爆炸</p>
<p>考虑优化边的数量，每个点只向自己去掉一个二进制一个 $1$ 的点连边，这样复杂度 $O(20\cdot 2^{20})$，$01~bfs$ 即可</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/16/某场模拟赛-walk/">某场模拟赛 walk</a> </p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的序列 $a_i$，求所有子区间的和的异或和</p>
<p>$n\le 10^5,\sum a \le 10^6$</p>
<p>简要题解：将区间和变成前缀和相减，然后按位考虑</p>
<p>假设现在在考虑第 $k$ 位，我们把包括第 $k$ 位在内的高位都扔掉</p>
<p>然后我们考虑 $x - y$</p>
<p><strong>如果 $x$ 的第 $k$ 位是 $1$，那么 $y$ 的 $k$ 位是 $1$ 且 $x&lt;y$ 或 $y$ 的第 $k$ 位是 $0$ 且 $x\ge y$ 才能保证 $x-y$ 的第 $k$ 位是 $1$​ ​</strong></p>
<p>$x$ 的第 $k$ 位是 $0$ 的情况正好相反</p>
<p>这个大小关系可以用树状数组维护，时间复杂度 $O(n\log^2 \sum a_i)$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/24/Luogu-P3760-TJOI2017-异或和/">Luogu P3760 [TJOI2017]异或和</a> 相减和相加的情况类似</p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的非降序列 $a_i$，每次操作可以选择两个相邻的数 $a_i$ 和 $a_{i+1}$ 然后将这两个数移除，放回 $a_i\oplus a_{i+1}$，求最少多少次操作可以使其不在是非降序列，注意 $n=1$ 时仍然认为是非降</p>
<p>$n\le 2\times 10^5,a_i\le 10^9$</p>
<p>简要题解：注意到如果有连续三个数的最高位相同，则我们异或后面两个就能使得序列不合法</p>
<p>由于原题保证数列递增，所以相邻数的最高位至少相等</p>
<p>那么如果 $n&gt;60$，答案一定为 $1$ 次，否则我们直接暴力即可</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/30/CF-1457D-XOR-gun/">CF 1457D XOR-gun</a> </p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的序列 $a_i$，求有多少子区间是合法的，定义一个子区间 $[l,r]$ 合法，当且仅当 $a_l\oplus a_r=\sum_{i=l}^ra_i$，其中 $\oplus$ 表示异或</p>
<p>$n\le 2\times 10^5,a_i &lt;2^{30}$</p>
<p>简要题解：注意到答案可能很少</p>
<p>我们考虑一种计数方式将答案分成两类，第一种是 $a[l]$ 和 $a[r]$ 的最高位不相等，第二种是 $a[l]$ 和 $a[r]$ 的最高位相等</p>
<p>首先考虑第一种，我们枚举 $l$，然后向右枚举 $r$，直到 $\sum_{i=l+1}^{r-1}a[i]\ge 2^{k+1}$，其中 $k$ 为 $a[l]$ 的二进制最高位</p>
<p>能够证明这样的时间复杂度为 $O(n\log a_i)$，我们倒着再次枚举一遍，注意到这样的话第一类答案只会算一次，第二类答案则会算两次，所以我们再多判一下最高位即可</p>
<p>时间复杂度证明：对于每个 $k$，最多枚举 $O(n)$，我们可以将每个含有 $2^k$ 的数当成一个隔板</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/30/CF-1438E-Yurii-Can-Do-Everything/">CF 1438E Yurii Can Do Everything</a></p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的序列 $a_i$，求有多少子区间满足区间或等于区间最大值</p>
<p>$n\le 2\times 10^5,a_i\le 10^9$</p>
<p>简要题解：首先我们知道区间或是大于等于区间最大值的</p>
<p>然后我们考虑枚举作为区间最大值的点，那么我们用单调栈可以求出一个数左边和右边第一个大于它的数</p>
<p>然后我注意到当且仅当区间中存在一个值，它有一个 $1$ 是区间最大值所没有的</p>
<p>所以我们求一下每个数左边和右边第一个这样的值，然后就可以愉快的求答案了，时间复杂度 $O(n\log c)$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/03/CF-875D-High-Cry/">CF 875D High Cry</a></p>
</li>
<li><p>简要题意：给定 $n$ 个点，编号依次为 $[0,n-1]$，对于任意两个点 $u,v$，边 $(u,v)$ 的权值为 $u\oplus v$，其中 $\oplus$ 为异或，求最小生成树</p>
<p>$n\le 10^{12}$</p>
<p>简要题意：一个结论，答案为 $\sum_{i=1}^{n-1} i ~\&amp;~ (-i)$，换句话讲点 $i$ 连向点 $i~xor~ (i ~\&amp;~ (-i))$</p>
<p>我们考虑 $Boruvka$，首先第一次连边一定是 $0$ 到 $1$，$2$ 到 $3$，且边权为 $1$</p>
<p>下一次连边的边权为 $2$，在下一次为 $4$，稍微画画大概就能找到规律，<a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/58712">正规证明</a></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/24/CF-959E-Mahmoud-and-Ehab-and-the-xor-MST/">CF 959E Mahmoud and Ehab and the xor-MST</a></p>
</li>
<li><p><a href="">CF 981D Bookshelves</a> 从高位到低位贪心即可，对于之前的局面只需要存储值即可</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/02/24/CF-986C-AND-Graph/">CF 986C AND Graph</a> 当且仅当两点的权值的与为 $0$，两点之间连边，求连通块个数</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/03/21/2020-2021-Winter-Petrozavodsk-Camp-Belarusian-SU-Contest-XXI-Open-Cup-Grand-Prix-of-Belarus-D-Bank-Security-Unification/">2020-2021 Winter Petrozavodsk Camp, Belarusian SU Contest (XXI Open Cup, Grand<br>  Prix of Belarus) D Bank Security Unification</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/03/21/2020-2021-Winter-Petrozavodsk-Camp-Belarusian-SU-Contest-XXI-Open-Cup-Grand-Prix-of-Belarus-C-Brave-Seekers-of-Unicorns/">2020-2021 Winter Petrozavodsk Camp, Belarusian SU Contest (XXI Open Cup, Grand<br>  Prix of Belarus) C Brave Seekers of Unicorns</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/04/06/CF-766E-Mahmoud-and-a-xor-trip/">CF 766E Mahmoud and a xor trip</a> 拆位啊，拆位</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/07/25/2021%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A13-I-Kuriyama-Mirai-and-Exclusive-Or/">2021牛客多校3 I Kuriyama Mirai and Exclusive Or</a> 连续数字的 $2^i$​ 这个二进制位是按照 $2^{i+1}$​ 为循环节，且这种情况下的每个二进制位的差分标记是每隔 $2^i$​​​ 打一个</p>
</li>
<li><p>简要题意：给定 $n$ 个数 $a_i$ 和 $m$ 次询问，每次询问给定四个参数 $b,x,l,r$，表示从 $a[l]$ 到 $a[r]$ 选择最大的 $b\oplus (a_i+x)$，其中 $\oplus$ 表示异或</p>
<p>$n,m\le 2\times 10^5,0\le a,b,x\le 10^5$</p>
<p>简要题解：我们考虑从高位到低位贪心，我们不妨假设现在已经选出的数的大小为 $ans$，那么现在要选第 $i$ 位，根据 $b$ 是否有 $i$ 这个二进制位，$a+x$ 的区间是 $[ans,ans+2^i-1]$ 或 $[ans+2^i,ans+2^{i+1}-1]$​，区间查询是否有一个数的大小属于某个区间可以用主席树维护，时间复杂度 $O(n\log ^2n)$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/08/08/Luogu-P3293-SCOI2016-%E7%BE%8E%E5%91%B3/">Luogu P3293 [SCOI2016]美味</a></p>
</li>
<li><p>简要题意：给定 $n$ 个物品和 $m$ 个属性以及常数 $w$，第 $i$ 个物品有一个价值 $c_i$ 以及其所拥有的属性 $S_i$，现在要依次选择若干个物品，满足相邻两个物品 $i$ 和 $j$ 满足 $i&lt;j\wedge w+c_i\ge c_j\wedge S_i\subseteq S_j$，求最多选择多少个物品</p>
<p>$n\le 10^5,m\le 18$</p>
<p>简要题解：首先考虑 $cdq$ 分治解决第一个和第二个限制，对于第三个限制，我们考虑每次 $cdq$ 分治的时候将左部的每个点都贡献到自己的超集，这样可以做到 $O(2^m)$ 预处理，$O(1)$ 查询，或者我们考虑用右部的每个点求子集查询，这样是 $O(1)$ 预处理，$O(2^m)$ 查询，我们可以平衡一下，前 $\frac n 2$ 位贡献到超集，后 $\frac n 2 $ 子集查询，这样做的时间复杂度为 $O(2^{\frac n 2}n\log n+n\log^2 n)$</p>
<p><strong>二进制平衡</strong></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/09/24/Luogu-P7842-%E3%80%8CC-E-L-U-03%E3%80%8D%E6%8E%A2%E9%99%A9%E8%80%85%E7%AC%94%E8%AE%B0-III/">Luogu P7842 「C.E.L.U-03」探险者笔记 III</a></p>
</li>
<li><p>简要题意：给定 $n$ 个点完全图，第 $i$ 个点的权值是 $a_i$，对于连接 $(u,v)$ 边，它的权值是 $a[u]~xor~a[v]$ 求最小生成树</p>
<p>$n\le 2\times 10^5$</p>
<p>简要题解：我们考虑 $kruskal$ 按照边的权值加边</p>
<p>我们考虑利用 $01Trie$ 的分治过程，对于分治的左右部分，因为每个部分内部的边的权值一定小于跨过两边的权值，所以内部肯定已经练好，为了将两边连接，我们只需要找一条最小的边即可，这个可以用 $01Trie$ 来做</p>
<p>时间复杂度 $O(n\log^2 n)$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/10/19/CF-888G-Xor-MST/">CF 888G Xor-MST</a></p>
</li>
<li><p>简要题意：给定一个棵有 $n$ 个点的无根树，现在有 $m$ 次操作，操作有两种，给定 $x,y$ 求 $x$ 到 $y$ 的简单路径上所有点组成的可重集合的子异和；给定 $x,y,z$ 将 $x$ 到 $y$ 上每个点异或上 $z$，其中集合 $S$ 子异和的定义为子集 $S$ 的所有子集的异或和的和</p>
<p>$n,m\le 2\times 10^5$</p>
<p>简要题解：我们考虑集合 $S=\lbrace a_1,a_2\cdots,a_n\rbrace$ 的子异和，我们按位考虑对于第 $i$ 个二进制位，我们不妨假设有 $x$ 个 $1$ 和 $y$ 个 $0$，我们有 $x+y=n$，容易得到异或和为 $1$ 的子集个数为 $2^y\sum_{i=0}^x\binom{x}{i}[i\equiv 1(\bmod 2)]=2^{x+y-1}=2^{n-1}$，另外需要注意如果 $x$ 为 $0$，则答案为 $0$，这样容易得到答案就是 $2^{n-1}$ 乘上 $S$ 的所有数的或</p>
<p>我们首先树剖，那么现在只需要支持求区间或和区间异或，我们用线段树维护区间或、区间与和区间异或标记，能推出如下的转移，时间复杂度 $O(n\log^2 n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = T[i].orsum, b = T[i].andsum;</span><br><span class="line">    T[i].orsum = a &amp; ~v | ~b &amp; v;</span><br><span class="line">    T[i].andsum = b &amp; ~v | ~a &amp; v;</span><br><span class="line">    T[i].tag ^= v; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/11/13/Luogu-P5127-%E5%AD%90%E5%BC%82%E5%92%8C/">Luogu P5127 子异和</a></p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的序列 $a_i$，求 $\sum_{i=1}^n\sum_{j=i+1}^{n}cnt_{a_i\oplus a_j}$，其中 $cnt_x$ 表示 $x$ 的二进制表示下 $1$ 的个数， $\oplus$ 表示异或</p>
<p>$n\le 36666666,a_i\le 2^{64}-1$</p>
<p>简要题解：首先容易得到 $O(n\log n)$ 的做法，即我们对于每一位统计 $0$ 和 $1$ 的数量 $s$ 和 $t$，这一位的贡献就是 $s\times t$</p>
<p>类比这个做法，我们一次枚举 $w$ 位，然后记录这 $w$ 位的结果，最后 $O(\frac{64}{w}(2^w)^2)$ 统计答案即可，时间复杂度为 $O(\frac{64}{w}(n+2^{2w}))$，取 $w = 8$ 即可通过此题</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/05/11/%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B-T1-%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9-%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%BC%82%E6%88%96/">校内模拟赛 T1 美好的每一天~不连续的异或</a></p>
</li>
<li><p>简要题意：现在有 $n$ 堆石子 $a_i$，$Alice$ 和 $Bob$ 准备玩最经典的取石子游戏，但是现在 $Bob$ 可以作弊，$Bob$ 在游戏开始前，可以选择移除 $k\in [0,n-1]$ 堆石子，现在再给定一个整数 $d$，求 $Bob$ 移除 $k$ 堆后先手必败的方案数，要求 $k$ 是 $d$ 的倍数</p>
<p>$n\le 5\times 10^5,d\le 10, a_i\le 10^6,\sum_{i=1}^na_i\le 10^7$，空间限制 $64MB$</p>
<p>简要题解：稍微转换一下题意能够得到我们需要求选了 $m\in [0,n-1]$ 堆，异或和为 $t$ 的方案数</p>
<p>首先 $d$ 的倍数等价于模 $d$ 为 $0$，所以我们不需要维护具体选了几堆，直接维护模 $d$ 为多少</p>
<p>另外注意到 $\sum_{i=1}^n a_i\le 10^7$，我们将 $a_i$ 排序，那么前面所有数的异或和是不会超过 $2^{hb+1}-1$ 的，$hb$ 为当前数二进制最高位的 $1$，那么我们直接做背包的复杂度就为复杂度为 $O(d\sum_{i=1}^na_i)$，注意需要特判所有数都选的情况</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/05/22/%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B-T2-%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/">校内模拟赛 T2 取石子游戏</a></p>
</li>
<li><p>简要题意：现在有 $n$ 次询问，每次询问给定 $[l,r]$，求 $[l,r]$ 异或和/与和/或和 </p>
<p>$n\le 5\times 10^6, 0\le l\le r&lt; 2^{64}$ </p>
<p>简要题解：异或显然，或和与的公式就不在推导了，直接给出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) write(l &amp; <span class="number">-1u</span>ll &lt;&lt; __lg(l ^ r)); <span class="comment">// 与</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) write(r | (<span class="number">1u</span>ll &lt;&lt; __lg(l ^ r)) - <span class="number">1</span>); <span class="comment">// 或</span></span><br><span class="line"><span class="keyword">else</span> write(get_xor(r) ^ get_xor(l) ^ l);</span><br></pre></td></tr></table></figure>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的 $01$ 序列 $a_i$，现在要执行 $k$ 次操作，每次操作将所有 $a_i$ 异或上 $a_{i-1}$ 得到 $a’_i$，求最终的序列</p>
<p>$n\le 3\times 10^6,k\le 10^9$</p>
<p>简单分析容易得到 $a_i=\sum_{j=0}^i\binom{k}{i-j}a_j\bmod 2$，注意到模 $2$，那么组合数 $\binom{k}{x}$ 不等于 $0$ 当且仅当 $x$ 是 $k$ 的子集</p>
<p>那么如果我们取 $k=2^t$，那么 $\binom{k}{x}$ 只有当 $x$ 等于 $k$ 和 $0$ 是才为 $1$，那么我们可以将 $k$ 二进制拆分，每次做 $2$ 的次幂次操作，操作可以用 $bitset$ 加速，时间复杂度 $O(\frac{n\log k}{64})$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/07/06/2022-Jiangsu-Collegiate-Programming-Contest-H-Super-Gray-Pony/">2022 Jiangsu Collegiate Programming Contest H Super Gray Pony</a></p>
</li>
</ol>
<h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><ol>
<li><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/11/%E6%A0%A1%E5%86%85%E8%B5%9B-T1-%E5%85%83%E7%B4%A0%E5%B9%B3%E8%A1%A1/">校内赛-T1-元素平衡</a> </p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/05/CF-1453B-Suffix-Operations/">CF 1453B Suffix Operations</a> 前后缀操作将数组转换成差分数组之后相当于只操作一个位置</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/11/Luogu-P2882-USACO07MAR-Face-The-Right-Way-G/">Luogu P2882 [USACO07MAR]Face The Right Way G</a> 异或差分</p>
</li>
<li><p>简要题意：给定两个长度为 $n$ 的数列 $a_i,b_i$，现在有 $m$ 个操作，每次操作给定一个区间 $[l,r]$ 以及将要操作的数列是 $a$ 还是 $b$，然后将区间内的数按顺序加上 $f_i$，其中 $f$ 是斐波那契数列，求每次操作后 $a$ 数列是否和 $b$ 数列完全相同</p>
<p>$n,m\le 3\times 10^5$</p>
<p>简要题解：我们考虑差分，注意到 $a_{i+2}$ 所增加的数恰好为 $a_i$ 和 $a_{i+1}$ 所增加的数的和，那么我们构造一个这样的差分，令 $d_i=a_{i}-a_{i-1}-a_{i-2}$，那么这样一个区间加的操作，我们只需要修改 $a_{l},a_{l+1},a_{r+1},a_{r+2}$ 这四个位置即可</p>
<p>至于如何判断相等，我们只需要将其看做 $a-b$，然后维护 $0$ 的个数即可</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/02/16/CF-1634F-Fibonacci-Additions/">CF 1634F Fibonacci Additions</a></p>
</li>
</ol>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/02/2020%E5%B9%B4%E5%B9%BF%E8%A5%BF%E7%9C%81CCPC%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-A-Landlord/">2020年广西省CCPC大学生程序设计竞赛 A Landlord</a> 求有多少子矩阵的值小于给定数字</p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的字符串 $S$ 和一个整数 $k$，定义两个长度相同的字符串 $k$ 匹配为它们对应位置不同不超过 $k$ 次，求对于所有 $i\in[1,n-1]$，求出 $S$ 的 $pre_i$ 和 $suf_{i+1}$ 的 $k$ 匹配子串有多少个</p>
<p>$n,k\le 3000$</p>
<p>简要题解：我们考虑对于起始位置间隔为 $m$ 的两个起点 $s_1$ 和 $s_2$，满足 $s_2-s_1=m$，求最远的延伸长度 $l$，满足 $S[s_1,s_1+l-1]$ 与 $S[s_2,s_2+l-1]$ $k$ 匹配，注意到这个东西是有单调性的，即如果将 $s_1$ 和 $s_2$ 均向后一位，终点也会向后移动</p>
<p>对于所有 $m\in[1,n-1]$ 都求完答案后，我们会得到 $O(n^2)$ 个三元组 $(s_1,s_2,l)$​ 表示两个起点和延伸长度，一个三元组对答案的贡献可以轻松得到，对于这个贡献，我们可以差分两次来做到 $O(1)$ 累加</p>
<p>时间复杂度 $O(n^2)$​</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/08/11/2021%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A15-D-Another-String/">2021杭电多校5 D Another String</a></p>
</li>
</ol>
<h2 id="无删除双指针"><a href="#无删除双指针" class="headerlink" title="无删除双指针"></a>无删除双指针</h2><p>模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, mid = <span class="number">0</span>, r = <span class="number">1</span>, ans = <span class="number">0</span>; R.setone();</span><br><span class="line"><span class="keyword">while</span> (r &lt;= n) &#123;</span><br><span class="line">    R = R * a[r];</span><br><span class="line">    <span class="keyword">while</span> (!l || (L[l] * R).a[<span class="number">1</span>][m] == lim + <span class="number">1</span>) &#123;</span><br><span class="line">        ++l;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">            L[r] = a[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= l; --i) L[i] = a[i] * L[i + <span class="number">1</span>];</span><br><span class="line">            R.setone();</span><br><span class="line">            mid = r; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ans = max(ans, r - l + <span class="number">1</span>);</span><br><span class="line">    ++r;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="调和级数"><a href="#调和级数" class="headerlink" title="调和级数"></a>调和级数</h2><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/10/Uoj-21-%E3%80%90UR-1%E3%80%91%E7%BC%A9%E8%BF%9B%E4%BC%98%E5%8C%96/">Uoj #21【UR-1】缩进优化</a> 找到一个 $k$ 使得 $\sum_{i=1}^n a_i-(k-1)\sum_{i=1}^n\lfloor \frac{a_i}{k}\rfloor$ 最小，其中 $a_i$ 和 $n$ 同阶</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/29/CF-691-Couple-Cover/">CF 691 Couple Cover</a></p>
<p><a href="">CF 1398F Controversial Rounds</a></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/02/18/CF-632D-Longest-Subsequence/">CF 632D Longest Subsequence</a></p>
<h2 id="一些比较杂的东西"><a href="#一些比较杂的东西" class="headerlink" title="一些比较杂的东西"></a>一些比较杂的东西</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/14/Luogu-P3295-SCOI2016-萌萌哒/">Luogu P3295 [SCOI2016]萌萌哒</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/22/Luogu-P5227-AHOI2013-连通图/">bzoj 3237 [Ahoi2013]连通图</a></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/01/17/Luogu-P5631-%E6%9C%80%E5%B0%8Fmex%E7%94%9F%E6%88%90%E6%A0%91/">Luogu P5631 最小mex生成树</a></p>
</li>
<li><p>坐标变换，<a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/22/Luogu-P4169-Violet-天使玩偶-SJY摆棋子/">Luogu P4169 [Violet]天使玩偶/SJY摆棋子</a></p>
</li>
<li><p>$O(1)$ 乘</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    ll lf = a * (b &gt;&gt; <span class="number">25l</span>l) % p * (<span class="number">1</span> &lt;&lt; <span class="number">25l</span>l) % p;</span><br><span class="line">    ll rg = a * (b &amp; (<span class="number">1l</span>l &lt;&lt; <span class="number">25</span>) - <span class="number">1</span>) % p;</span><br><span class="line">    <span class="keyword">return</span> (lf + rg) % p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x * y - (ll) ((ldb) x / p * y) * p + p) % p;</span><br><span class="line">&#125; <span class="comment">// 第一个好像要慢一点，但第二个有可能会出错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>平方分解</strong></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/25/%E6%A0%A1%E5%86%85%E8%B5%9B-T1-%E5%AF%BB%E8%B7%AF/">校内赛 T1 寻路</a></p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的序列 $a_i$，求 $\sum_{i=1}^n\sum_{j=1}^n(a_i\oplus a_j)^2$，$\oplus$ 代表异或运算</p>
<p>$n\le 5\times 10^5$</p>
<p>简要题解：我们考虑平方分解：$(\sum_{i=1}^na_i)^2=\sum_{i=1}^n\sum_{j=1}^na_ia_j$</p>
<p>那么对于 $(a_i\oplus a_j)^2$，我们可以看做是若干个二进制的和的平方，那么我们现在只需要枚举两个二进制位进行计算即可，时间复杂度 $O(n\log ^2n)$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/10/31/2021-CCPC-%E6%96%B0%E7%96%86%E7%9C%81%E8%B5%9B-H-xor/">2021 CCPC 新疆省赛 H xor</a></p>
</li>
</ol>
</li>
<li><p>对于两个区间 $[a,b]$ 和一个固定长度的区间 $L$，他们的交的最大值是两个区间中点距离最近的时候</p>
<p>换句话讲，区间中点的距离和交的值是负相关的，区间中点的距离越小，交的值不降 <a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/11/25/CF-1452E-Two-Editorials/">CF 1452E Two Editorials</a> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/05/CF-1405C-Balanced-Bitstring/">CF 1405C Balanced Bitstring</a> 给定一个 $01$ 串，串中有一些位置可以随便填 $0$ 或 $1$，要求每个长度为 $k$ 的子串均有相等的 $0$ 和 $1$</p>
</li>
<li><p>每个物品的重量大于等于小于它的物品的重量的二倍，这个东西类似于二进制</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/07/2020-2021-ACM-ICPC-Brazil-Subregional-Programming-Contest-H-SBC-s-Hangar/">2020-2021 ACM-ICPC Brazil Subregional Programming H SBC’s Hangar</a></p>
</li>
<li><p>一棵树上，统计每个点的祖先对其的贡献，可以在 $dfs$ 到一个点的时候，把它的贡献加上，离开的时候再减去 <a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/07/2020-2021-ACM-ICPC-Brazil-Subregional-Programming-Contest-E-Party-Company/">2020-2021 ACM-ICPC Brazil Subregional Programming Contest E Party Company</a></p>
</li>
<li><p>$\lfloor \frac{n}{i}\rfloor$ 的 $hash$ 方法，只需要用到两倍的空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Div_hash</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, sn; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123; n = _n; sn = <span class="built_in">sqrt</span>(n); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt;= sn ? x : sn * <span class="number">2</span> - n / x + <span class="number">1</span>; &#125; </span><br><span class="line">&#125; _;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有一棵点的颜色为黑色或白色的树，现在有偶数个黑点，每条边选择与否可以翻转连接的两个点的颜色</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/12/CF-840B-Leha-and-another-game-about-graph/">CF 840B Leha and another game about graph</a></p>
</li>
<li><p>合法答案是一个区间，二分两边端点</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/20/CF-1463D-Pairs/">CF 1463D Pairs</a></p>
</li>
<li><p>求合法数对的另一方法 <a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/20/CF-917A-The-Monster/">CF 917A The Monster</a></p>
</li>
<li><p>下面东西看起来像是 $O(n(\sum a_i)^2)$，其实是 $O(n\sum a_i+(\sum a_i)^2)$ 的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s[i - <span class="number">1</span>]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= a[i]; ++k)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/20/CF-922E-Birds/">CF 922E Birds</a></p>
</li>
<li><p>$\sum_{i=0}^kp^i$ 可以递归求解</p>
<p>当 $k$ 为奇数时，$\sum_{i=0}^k p^i=\sum_{i=0}^{\frac{k-1}{2}}p^i\cdot (1+p^{\frac{k+1}{2}})$</p>
<p>当 $k$ 为偶数时，$\sum_{i=0}^kp^i=\sum_{i=0}^{\frac{k}{2}-1}p^i\cdot (1+p^{\frac{k}{2}+1})+p^{\frac{k}{2}}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> solve(a, n / <span class="number">2</span>) * (<span class="number">1</span> + pow_mod(a, n / <span class="number">2</span> + <span class="number">1</span>)) % p; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (solve(a, n / <span class="number">2</span> - <span class="number">1</span>) * (<span class="number">1</span> + pow_mod(a, n / <span class="number">2</span> + <span class="number">1</span>)) + pow_mod(a, n / <span class="number">2</span>)) % p;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>将第 $k$ 位变成 $v+k-1$，可以直接抹平</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/27/%E7%89%9B%E5%AE%A2-contest-9934J-Pass-Through-With-One-Breath/">牛客 contest 9934J Pass Through With One Breath</a></p>
</li>
<li><p>统计所有数对 $(l,r)$ 的价值，其中 $(l,r)$ 的价值为 $[l,r]$ 中的最小值乘以最大值</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/28/%E6%A8%A1%E6%8B%9F%E8%B5%9B-sequence-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC%E5%88%86%E6%B2%BB/">模拟赛-sequence(最大最小值分治)</a></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2020/12/28/CF-gym-102562B-Bitwise-Party/">CF gym 102562B Bitwise Party</a> 最大值或上最小值，求所有区间的价值的异或和</p>
<ol>
<li><p>简要题意：给定一个长度为 $n$ 的序列，求有多少区间 $[l,r]$ 满足，区间 $[l,r]$ 的最小值 $mn$ 和最大值 $mx$ 的二进制表示 $1$ 的个数相同</p>
<p>$n\le 10^6, a_i\le 10^{18}$</p>
<p>简要题解：我们考虑经典的最小值最大值分治，枚举左端点，维护左边区间的后缀 $max$ 和 $min$，同时维护两个位置 $pm$ 和 $pn$ 表示左边当前位置的后缀 $max$ 和 $min$ 在右边区间仍然是最大值和最小值的最靠右的位置</p>
<p>对于右端点在 $[m+1,\min\lbrace pn,pm\rbrace]$，区间最大值和最小值都在左边，直接判断 $max$ 和 $min$ 的位数是否相等即可</p>
<p>右端点在 $[\min\lbrace pn,pm\rbrace+1,\max\lbrace pn,pm\rbrace]$，区间最大值或者最小值在左边，另一个在右边，我们相当于要统计 $[\min\lbrace pn,pm\rbrace+1,\max\lbrace pn,pm\rbrace]$ 内二进制表示 $1$ 的个数为定值的个数，这个东西如果我们预处理前缀和的话复杂度是 $O(n\log ^2 n)$，但如果我们离线下来做一个差分，这样就能做到 $O(n\log n)$</p>
<p>右端点在 $[\max\lbrace pn,pm\rbrace +1,r]$，可以预处理，时间复杂度 $O(n\log n)$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/12/14/CF-1609F-Interesting-Sections/">CF 1609F Interesting Sections</a></p>
</li>
</ol>
</li>
<li><p>给你一串 <code>01</code> 或 <code>?</code> 组成的字符串，询问对于每个 $len$，若有连续 $len$ 个相同的字符组成的子字符串，那么就从中删去，问最多可以删多少次，<code>?</code> 表示这个可以认为是 <code>0</code>，也可以认为是 <code>1</code></p>
<p>用并查集维护右边第一个合法的起点，随着 $len$ 的增加，并查集只会合并</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/01/07/CF-1398F-Controversial-Rounds/">CF 1398F Controversial Rounds</a></p>
</li>
<li><p>所有区间覆盖的情况都可以通过将相交区间变成一个大区间和一个被大区间包含的小区间，从而使得区间覆盖变成括号序列（存疑</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/01/09/CF-1400E-Clear-the-Multiset-dp/">CF 1400E Clear the Multiset(dp)</a></p>
</li>
<li><p>如果一条路径可逆，那么我们可以通过变换终点和起点来降低复杂度</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/01/14/CF-1467D-Sum-of-Paths/">CF 1467D Sum of Paths</a></p>
</li>
<li><p>倒叙枚举前缀翻转可以不用平衡树</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/01/17/CF-1382C2-Prefix-Flip-Hard-Version/">CF 1382C2 Prefix Flip (Hard Version)</a></p>
</li>
<li><p>求连通块的其它方法，我们从每一个没到过的点开始 $dfs$，每次开始 $dfs$ 就代表有一个新的连通块</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/02/24/CF-986C-AND-Graph/">CF 986C AND Graph</a></p>
</li>
<li><p>一种基于笛卡尔树启发式合并的处理带有最值的数对问题</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/03/03/CF-1175F-The-Number-of-Subpermutations/">CF 1175F The Number of Subpermutations</a></p>
</li>
<li><p>如果加点均满足 $(l,r),l\le r$ 那么二维树状数组可以用来做矩阵查询</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/03/29/2020-2021-ACM-ICPC-Asia-Seoul-Regional-Contest-I-Stock-Analysis/">2020-2021 ACM-ICPC, Asia Seoul Regional Contest I Stock Analysis</a> </p>
</li>
<li><p>连通块的个数等于点的个数减掉边的个数（某些情况下</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/04/16/Luogu-P3616-%E5%AF%8C%E9%87%91%E6%A3%AE%E6%9E%97%E5%85%AC%E5%9B%AD/">Luogu P3616 富金森林公园</a></p>
</li>
<li><p>将矩阵看成邻接矩阵从而转化成图论问题</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/05/04/CF-632F-Magic-Matrix/">CF 632F Magic Matrix</a></p>
</li>
<li><p>询问在正向操作时很难处理，逆向操作时较为简单</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/05/16/CF-466E-Information-Graph/">CF 466E Information Graph</a></p>
</li>
<li><p>每次转移可以看做是从所有点 $s$ 以相同的方法跳 $k$ 次，且我们只需要记录是否可达</p>
<p>那么显然当我们跳到一个已经到过的点就可以直接停止，因为之后会从这个点接着跳</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/05/30/CF-1498D-Bananas-in-a-Microwave/">CF 1498D Bananas in a Microwave</a></p>
</li>
<li><p>通过交换 $a_i$ 最大化 $\sum_{i=1}^n |a_i-b_i|$</p>
<ol>
<li><p>首先我们思考如何求可以交换无限次后这个东西的最大值</p>
<p>我们首先考虑将绝对值拆开，那么相当于在 $a_i$ 和 $b_i$ 上分别加上正号和负号，且只需要总的正号的数量等于负号的数量即可，不要求 $a$ 中的正号等于负号的数量，那么这个时候最大值就是将 $a$ 和 $b$ 中的所有数拿出来排序然后前 $n$ 个取正号，后 $n$ 个取负号</p>
<p>另外我们需要知道，有可能出现正负号和实际绝对值相反的情况，但是如果交换这一对正负号，只会使得解变优，所以在题目求最优的前提下，正负号是可以随意分配的</p>
</li>
<li><p>接下来我们考虑给定 $a$ 和 $b$ 后如何求最小需要交换多少次可以达到最大值</p>
<p>我们按照之前的想法将符号分配好，那么需要交换的都是 $(+a_i,+b_i)$ 和 $(-a_i,-b_i)$，所以我们每次换一下 $++$ 和 $—$ 即可，注意到 $++$ 的数量一定等于 $—$ 的数量</p>
</li>
<li><p>然后我们在思考给定 $a$ 和 $b$ 以及可以交换的次数 $k$ 之后，如何求恰好交换 $k$ 次后的最大值</p>
<p>首先给出一个结论，在 $n&gt;2$ 的情况下，恰好交换 $k$ 次和至多交换 $k$ 次是一样的</p>
<p>不妨假设我们交换了 $s(s&lt;k)$ 次就得到了最优答案且已经分配好了符号，那么 $a$ 中至少有两个 $a$ 是同符号的，我们只需要交换这两个 $a$ 即可</p>
<p>那么在有这个结论之后，我们考虑如何交换，对于 $(a_i,b_i)$ 和 $(a_j,b_j)$，如果交换之后答案更优，需要这两个区间没有交点，且交换之后的价值会增加 $2\times (min\lbrace a_i,b_i\rbrace-max\lbrace a_j,b_j\rbrace)$，通过这个式子我们发现可以将贡献拆开，那么我们直接对于 $min\lbrace a_i,b_i\rbrace $ 和 $-max\lbrace a_i,b_i\rbrace$ 排序取前 $k$ 大相加即可</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/07/17/2021%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A11-G-Game-of-Swapping-Numbers/">2021牛客多校1 G Game of Swapping Numbers</a></p>
</li>
<li><p>拆绝对值分配正负号</p>
<p>简要题意：给定 $2n$ 个数对 $(a_i,b_i)$，现在要求将这 $2n$ 个数对分成 $n$ 组，如果 $x$ 和 $y$ 分到一组，那么这一组的贡献是 $max\lbrace|a_i-a_j|,|a_i-b_j|,|b_i-a_j|,|b_i-b_j|\rbrace$，求最大分配</p>
<p>简要题解：不妨令 $a_i\le b_i$，我们考虑拆掉绝对值，那么这 $2n$ 个数对中，一定有 $n$ 个的贡献是 $-a_i$，另外 $n$ 个贡献是 $+b_i$</p>
<p>关于如何选择每个数对的是负贡献还是正贡献，我们任取两个数对来考虑，$-a_1+b_2&gt;a_2+b_1$ 等价于 $a_1+b_1&lt;a_2+b_2$，那么我们按照 $a_i+b_i$ 来排序，前 $n$ 个取 $-a$，后 $n$ 个取 $b$ 即可</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/03/14/2021-ICPC-Southeastern-Europe-Regional-Contest-G-Max-Pair-Matching/">2021 ICPC Southeastern Europe Regional Contest G Max Pair Matching</a></p>
</li>
<li><p>一个经典的拆 $max$ 的做法</p>
<p>$f_i=max(f_{i-1}+d_i,u_i)$，其中 $f_l=u_l$ 且需要满足 $f_i\le v_i$，问区间 $[l,r]$ 是否满足</p>
<p>我们拆开这些 $max$，可以得到下面这个式子</p>
<p>$u_l\le v_l,max(u_l+d_l,u_{l+1})\le v_{l+1},max(u_l+d_l+d_{l+1},u_{l+1}+d_{l+1},u_{l+2})\le v_{l+2},\cdots$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/07/20/2021%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A11-J-Journey-among-Railway-Stations/">2021牛客多校1 J Journey among Railway Stations</a></p>
</li>
<li><p>简要题解：给定长度 $n$​ 和若干个前缀的单调栈的大小，要求构造一个满足条件的排列</p>
<p>$n\le 10^6$​</p>
<p><strong>构造排列时，我们可以考虑构造符合大小关系的有向图，然后跑拓扑序</strong></p>
</li>
<li><p>简要题意：给定 $n$ 个区间和 $k$，求将所有区间划分成 $k$ 组的最大价值和，每组区间的价值为它们的交，交不能为空，如果无法划分输出 $-1$</p>
<p>$1\le k\le n\le 5000$​ </p>
<p>简要题解：将包含其它的区间去掉，然后就可以保证相邻若干个分一组，令 $f[i][j]$ 表示前 $i$ 个分了 $j$ 组，单调队列优化可以做到 $O(nk)$</p>
<p><strong>将包含其它区间的大区间去掉后，按左端点排序可保证右端点也单调</strong></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/07/24/2021%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12-G-League-of-Legends/">2021牛客多校2 G League of Legends</a></p>
</li>
<li><p>简要题意：给定一个 $n\times m$ 的矩形，要求在每个位置填 $0$ 或 $1$，要求每一行和每一列的异或和都是 $k$，求方案数</p>
<p>$1\le n,m\le 10^{18}$</p>
<p>简要题解：注意到我们前 $n-1$ 行 $m-1$ 列无论怎么填，最后一行和最后一列都能选择对应的数字满足条件</p>
<p>需要注意的是如果 $|n-m|$ 是奇数且 $k=-1$ 的情况是无解的</p>
<p>其他情况下答案就是 $2^{(n-1)\times (m-1)}$</p>
<p><strong>前面乱选，只通过调整最后一部分来满足约束</strong></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/07/25/CF-894B-Ralph-And-His-Magic-Field/">CF 894B Ralph And His Magic Field</a> </p>
</li>
<li><p>简要题意：给定一棵 $n$ 个点的无根树和 $k$，求所有划分成 $k+1$​ 个连通块的方案的价值和，一个划分方案的价值定义为 $k+1$ 的连通块的大小的乘积</p>
<p>$n\le 5\times 10^4,k\le 100$</p>
<p>简要题解：</p>
<p>最朴素的 $dp$ 是 $f[u][m][S]$，表示分成了 $m$ 棵子树，$u$ 所在的子树的大小是 $S$</p>
<p>但是这样的时间复杂度显然无法通过此题，我们考虑求一个等价的问题，删掉 $k$ 条边，并且在每个连通块里都选恰好一个点的方案数</p>
<p>我们令 $f[u][m][0/1]$ 表示已经断了 $m$ 条边，$u$​​ 所在的子树是否已经选点，时间复杂度 $O(nk^2)$​</p>
<p><strong>将一棵树划分成 $k+1$ 个连通块的所有方案数 等价于 删掉 $k$ 条边，并且在每个连通块里都选恰好一个点的方案数</strong></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/07/28/2021%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14-D-Rebuild-Tree/">2021牛客多校4 D Rebuild Tree</a></p>
</li>
<li><p>简要题意：简要题意：给定两棵大小均为 $n$ 的树，求一个最大的点集满足，这些点在第一棵树上构成一条深度递增的链，即满足所有点之间都存在祖宗关系，在第二棵树上任意两点不存在祖宗关系</p>
<p>$n\le 3\times 10^5$</p>
<p>简要题解：我们考虑对于每个点求其作为链的最底端的答案，我们令 $h[u]$ 表示 $u$ 作为最底端时，深度最深的点满足在第二颗树上与 $u$ 存在祖先关系的点的深度</p>
<p>那么答案显然是 $max\lbrace dep[u]-h[u]\rbrace$</p>
<p>我们考虑如何求 $h$，注意到两个点 $u$ 和 $v$ 如果存在祖先关系，当且仅当 $u$ 的子树和 $v$ 的子树有交，那么我们在第一棵树上 $dfs$，然后每到一个点 $u$，我们就将线段树上 $in[u]$ 到 $out[u]$ 都与 $dep[u]$ 取 $max$，但是取 $max$ 并不能撤回，所以我们考虑直接用主席树，时间复杂度 $O(n\log n)$</p>
<p><strong>树上两点 $u$ 和 $v$ 如果存在祖先关系当且仅当 $u$ 的子树和 $v$ 的子树有交</strong> </p>
<p><strong>给定一个序列 $a$，有 $a_i&gt;i$，求最长的一段子区间 $[l,r]$ 满足 $(max_{i=l}^ra_i)&gt;r$，我们可以枚举每个点作为左端点，右端点就是 $max_{j=i}^na_j-1$​</strong></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/08/08/2021%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A17-F-xay-loves-trees/">2021牛客7 F xay loves trees</a></p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的序列 $a_i$，求有多少子区间存在绝对众数</p>
<p>$n\le 5\times 10^6$​</p>
<p>我们考虑数字 $v$ 作为绝对众数出现的区间，我们令 $v$ 所在的位置都是 $1$，其它位置都是 $-1$，那么显然区间和大于 $0$ 的区间都是 $v$ 作为绝对众数出现的区间</p>
<p><strong>$+1/-1$ 序列的前缀和的逆序对可以 $O(n)$，甚至可以在 1 的个数 或者 $-1$​​ 的个数 的时间复杂度内完成​</strong></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/08/13/Luogu-P4062-Code-1-Yazid-%E7%9A%84%E6%96%B0%E7%94%9F%E8%88%9E%E4%BC%9A/">Luogu P4062 [Code+#1]Yazid 的新生舞会</a></p>
</li>
<li><p>简要题意：给定一张 $n$ 个点 $m$ 条边的无向连通图，每个点有一个权值 $a_i$，每次操作可以使一条边相连的两个点同时增加任意一个整数值，求是否能使所有点的权值都为 $0$​</p>
<p>$n,m\le 2\times 10^5$</p>
<p>简要题解：首先注意到我们的操作不能改变权值总和的奇偶性，所以如果和为奇数则一定不行</p>
<p>然后我们注意到我们可以将距离为奇数的两个点同时增加相同的数值，距离为偶数的点一个增加另一个减少相同的数值</p>
<p>这启示我们考虑二分图的性质，首先我们将这张图分成两种情况考虑，二分图和不是二分图</p>
<p>如果该图是二分图，那么我们只需要看一下两边点的总和是否相等，相等则一定有解，不相等则一定无解</p>
<p><strong>如果该图不是二分图，那么就一定存在奇环，对于一个存在奇环的图，任意两个点都存在一条长度为奇数的路径，所以一定有解</strong></p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2021/08/24/CF-1537F-Figure-Fixing/">CF 1537F Figure Fixing</a></p>
</li>
<li><p>简要题意：给定一个 $n$ 个点 $m$ 条边的带权无向图，现在有 $k$ 次询问，每次询问给定一个常数 $x$，求如果将边权改为 $|w-x|$，$w$ 为改之前的边权，求最小生成树</p>
<p>$n\le 50,m\le 300,k\le 10^7$</p>
<p>简要题解：对于求最小生成树，我们优先考虑 $kruskal$ 算法，另外注意到询问非常多，我们考虑离线处理</p>
<p><strong>注意到如果我们使用 $kruskal$ 的话，那么我们只需要关注所有边的边权的相对关系，注意到只有当 $x$ 为 $\lceil\frac{w_i+w_j}{2}\rceil$ 时，$w_i$ 和 $w_j$ 这两条边的位置会发生变化，那么容易得到只有 $O(m^2)$ 种顺序，且每种顺序的 $x$ 都是一个区间&amp;</strong></p>
<p>然后我们考虑如何处理询问，我们离线后对于每种顺序的左端点为 $x$ 将边排序后做 $kruskal$ 即可，记录选中的边原本的权值是否大于 $x$，然后就可以求出答案</p>
<p>有几个需要注意的地方，分界点除了 $\lceil\frac{w_i+w_j}{2}\rceil$ 以外，还要加入每种边的权值，这样可以防止边原本的权值和 $x$ 的大小关系发生变化，另外排序过程中第二关键字要按照边原本权值降序排序，保证答案尽量小</p>
<p>时间复杂度 $O(m^3\log m+k\log m^2)$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/02/13/CF-1633E-Spanning-Tree-Queries/">CF 1633E Spanning Tree Queries</a></p>
</li>
<li><p>简要题意：给定两个长度为 $n$ 的串 $S$ 和 $T$，现在可以将 $T$ 的某一个子串翻转，求翻转后 $S$ 和 $T$ 最多有多少个对应位置相等</p>
<p>$n\le 1000$</p>
<p>简要题解：对于这种<strong>区间翻转</strong>的问题，我们考虑区间 $dp$ 的思路，$f_{i,j}$ 由 $f_{i+1,j-1}$ 转移过来即可</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/03/26/The-2021-ICPC-Asia-Taipei-Regional-Programming-Contest-B-Maximum-Sub-Reverse-Matching/">The 2021 ICPC Asia Taipei Regional Programming Contest B Maximum Sub-Reverse Matching</a></p>
</li>
<li><p>简要题意：给定 $n$ 个点，对于每个点求一个离它最近且不是给定点的点，距离是曼哈顿距离</p>
<p>$n\le 2\times 10^5,x_i,y_i\le 2\times 10^5$</p>
<p>简要题解：注意到答案的点一定是距某个给定点为 $1$ 的点，我们把这些点都加进来跑多<strong>关键点</strong>最短路即可</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/03/23/CF-1651D-Nearest-Excluded-Points/">CF 1651D Nearest Excluded Points</a></p>
</li>
<li><p>简要题意：给定一个长度为 $n$ 的序列 $a_i$，令 $d_i=max(a_1, a_2, \cdots, a_i)-min(a_1, a_2, \cdots, a_i)$，现在要求重新排列 $a$，使得 $\sum_{i=1}^nd_i$ 最小</p>
<p>$n\le 2000$</p>
<p>简要题解：我们考虑向一个序列中添加一个最值，那么最值一定要放在序列的最后面，我们考虑用<strong>区间 $dp$ 来排序</strong></p>
<p>这里我们容易想到将 $a_i$ 排序，令 $f_{i,j}$ 为区间 $[i,j]$ 重拍后的最小代价，容易得到 $f_{i,j}=\min(f_{i+1,j},f_{i,j-1})+a_i-a_j$</p>
<p>时间复杂度 $O(n^2)$</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/04/03/daimayuan-668-%E4%BD%93%E8%82%B2%E8%8A%82/">daimayuan 668 体育节</a></p>
</li>
<li><p>简要题意：现在有一个长度为 $n$ 的序列 $a_i$，定义 $F_0(l,r)$ 为区间 $[l,r]$ 内的逆序对个数，同时 $F_k(l,r)=\sum_{i=l}^r\sum_{j=i}^rF_{k-1}(i,j)$，给定 $k$，求 $F_k(1,n)$</p>
<p>$n\le 3\times 10^5$ </p>
<p>简要题解：观察 $F_k(l,r)=\sum_{i=l}^r\sum_{j=i}^rF_{k-1}(i,j)$，容易发现这个东西类似于前缀和，<strong>区间前缀和</strong></p>
<p>我们考虑一个逆序对 $(x,y)$，它对 $F_k(l,r)$ 的贡献是相当与令 $a_y=1$，同时向后做 $k+1$ 次前缀和到 $r$ 的答案乘上令 $a_x=1$，同时向前做前缀和到 $l$ 的答案，那么就是 $\binom{r-x+k}{k}\times\binom{x-l}{k}$，这些东西用树状数组维护即可</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/05/01/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B98-E-Robotic-Girl/">牛客练习赛98 E Robotic Girl</a></p>
</li>
<li><p>简要题意：现在有 $n$ 堆石子 $a_i$，$Alice$ 和 $Bob$ 准备玩最经典的取石子游戏，但是现在 $Bob$ 可以作弊，$Bob$ 在游戏开始前，可以选择移除 $k\in [0,n-1]$ 堆石子，现在再给定一个整数 $d$，求 $Bob$ 移除 $k$ 堆后先手必败的方案数，要求 $k$ 是 $d$ 的倍数</p>
<p>$n\le 5\times 10^5,d\le 10, a_i\le 10^6,\sum_{i=1}^na_i\le 10^7$，空间限制 $64MB$</p>
<p>简要题解：稍微转换一下题意能够得到我们需要求选了 $m\in [0,n-1]$ 堆，异或和为 $t$ 的方案数</p>
<p>首先 $d$ 的倍数等价于模 $d$ 为 $0$，所以我们不需要维护具体选了几堆，直接维护模 $d$ 为多少</p>
<p>另外注意到 $\sum_{i=1}^n a_i\le 10^7$，我们将 $a_i$ 排序，那么前面所有数的异或和是不会超过 $2^{hb+1}-1$ 的，$hb$ 为当前数二进制最高位的 $1$，那么我们直接做背包的复杂度就为复杂度为 $O(d\sum_{i=1}^na_i)$，注意需要特判所有数都选的情况</p>
<p><a target="_blank" rel="noopener" href="https://ddosvoid.github.io/2022/05/22/%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B-T2-%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/">校内模拟赛 T2 取石子游戏</a></p>
</li>
<li><p>简要题意：给定一个 $n$ 个点 $m$ 条边的简单无向图，求是否存在一条链，使得将这条链上的点以及这些点的所有边都去掉后，剩下的点可以划分成两个集合，满足不同集合的点之间没有连边，链至少需要包含一个点，集合可以是空集</p>
<p>$n,m\le 2\times 10^5$</p>
<p>简要题解：我们考虑一种神奇的 $dfs$ 的方法</p>
<p>一开始我们令所有点都属于集合 $A$，我们从任意一个点开始 $dfs$，每当我们 $dfs$ 到一个点，我们将就其从 $A$ 中删除，加入到我们所选择的这条链中，当我们回溯到某一个点的时候，我们将其从链中删除，加入到集合 $B$，显然集合 $A$ 和集合 $B$ 中的点之间不会存在连边，同时每次我们会将集合 $A$ 的大小减一或者将集合 $B$ 的大小加一，那么一定有存在一个时刻，满足 $A$ 的大小等于 $B$ 的大小</p>
<p>时间复杂度 $O(n)$</p>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------　　　　本文结束　<i class="fa fa-flag"></i>　感谢阅读　　　　-------------</div>
    
</div>

          <div class="post-tags">
              <a href="/tags/Tech/" rel="tag"># Tech</a>
              <a href="/tags/%E5%A5%97%E8%B7%AF/" rel="tag"># 套路</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/11/Luogu-P3521-POI2011-ROT-Tree-Rotations/" rel="prev" title="Luogu P3521 [POI2011]ROT-Tree Rotations">
                  <i class="fa fa-chevron-left"></i> Luogu P3521 [POI2011]ROT-Tree Rotations
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/11/Luogu-P4366-Code-4-%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="next" title="Luogu P4366 [Code+#4]最短路">
                  Luogu P4366 [Code+#4]最短路 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DDOSvoid</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:01</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-use    r"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
